package main

import "fmt"

/*
插入排序：
对于[5,1,4,2]这个数组想实现插入排序
step1: 从i=1开始递增遍历数组，想让每一次在0到i上有序
step2: 对于arr[0-i]的子数组，从右向左看，若左边的数比第i个数大，则交换，直到左边没有数了

例如上面的数组：
step1: 想在[0-0]上有序， 已经满足
step2: 想在[0-1]上有序，由于5>1交换， [5,1] --> [1,5]
step3: 想在【0-2】上有序，上一步的有序数组为[1,5]新来了一个数变成为[1,5,4], 从4开始向左比较 --> [1,4,5]
step4: 想在[0-3]上有序，上一步的有序数组为[1,4,,5]新来了一个数变成为[1,4,5,2] --> [1,2,4,5]

时间复杂度：O(N**2)
注意：该算法的时间复杂度和数据结构有关，下面两个数组同样使用插入排序的时间复杂度不同
[1,2,3,4,5] O(N)
[5,4,3,2,1] O(N**2)

但是我们常说的时间复杂度是指这个算法的最差时间，因此该算法的时间负责度为O(N**2)
 */


func InsertSort(arr []int ) {
	if arr == nil || len(arr) < 2 {
		return
	}
	// 想在[0-0]上有序， 已经做到
	// 想在[0-i] i>=1上有序
	for i := 1; i < len(arr); i ++ {
		for j := i -1; j >=0 && arr[j] > arr[j+1]; j-- {
			swap(arr, j, j+1)
		}
	}
}



// 调用此方法必须保证 (i != j)
func swap(arr []int, i , j int) {
	arr[i]  = arr[i] ^ arr[j]
	arr[j] = arr[i] ^ arr[j]
	arr[i] = arr[i] ^ arr[j]
}

func main() {
	arr := []int{5, 1, 4,2}
	InsertSort(arr)
	fmt.Print(arr)
}
